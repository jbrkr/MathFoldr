#!/usr/bin/env node

const fs = require('fs')
const program = require('../lib/program')
const { serializeTaxonomy } = require('../index.js')
const { values } = require('../lib/utils.js')
const { pruneHierarchy } = require('../lib/jskos.js')

var chalk = require('chalk')

program
  .arguments('<file>')
  .option('-R, --prune <criteria>', 'prune hierarchy (e.g. mappings)')
  .description('process JSKOS concept scheme')

program.run({
  formats: ['txt', 'csv', 'json', 'ndjson'],
  serializer: serializeTaxonomy,
  action: function (file, env, error) {
    const format = file.match(/\.ndjson$/) ? 'ndjson' : 'json'
    const json = fs.readFileSync(file, 'utf8')
    var scheme = {}

    if (format === 'json') {
      scheme = JSON.parse(json)
      if (typeof scheme === 'array') {
        scheme = { concepts: scheme }
      }
    } else {
      var concepts = json.split(/\r?\n/).filter(line => line).map(JSON.parse)
      scheme = {
        concepts: concepts,
        topConcepts: values(scheme.concepts)
          .filter(c => !c.broader || !c.broader.length)
          .map(c => { return { uri: c.uri }})
      }
    }

    if (env.prune) {
      pruneHierarchy(scheme, env.prune)
    }

    const serializeOptions = {
      chalk: env.chalk,
      uris: env.uris,
      instancecount: true, // TODO: set from scheme or option
      sitecount: true, // TODO: set from scheme or option
    }

    env.serialize(scheme, env.out(), serializeOptions)
  }
})
